// tout ce qui est apres // est un commentaire

ubuntu
compile libsx (in order to get /hexa/libsx/src/libsx.a, it is the graphic library)
compile lib_dp 
compile batz (it is a graphic tool to see calculated structures)
compile phobos (it is a graphic tool to see the design of the structures)
compile unix_2004 (it is the tool for calculate the equilibrium of the structure in quasi static conditions)
compile  dyna2 (it is the tool for calculate the equilibrium of the structure in dynamic conditions)

Errors :
1) abs is used in place of fabs

REFERENCEMENT DES VARIABLES :

wf : position des noeuds dans le repère cartésien au temps t
wf1 : coordonnées des noeuds dans le repère cartésien au temps t-1
wf2 : coordonnées des noeuds dans le repère cartésien au temps t-2
wv : coordonnées du mouvement dans le repère cartésien
wfcodend : position des noeuds dans le repère lié au courant

mvb : vitesses des noeuds au temps t
mvb1 : vitesses des noeuds au temps t-1

mgb : acceleration des noeuds au temps t

mvbz : vitesses des noeuds au temps t + Pascalcul = mvb + Pascalcul * mgb
mvbm : vitesses des noeuds entre t et t+ Pascalcul = (mvbz+mvb)/2
wf + Pascalcul * mvbm : Estimation de la position à t +  Pascalcul

mh[3*zi] : hauteur de la surface libre en chaque noeud
mh[3*zi-1] : immersion des noeuds : >0 si flotteur, <0 si lest
mh[3*zi-2] : position x des noeuds dans le repère lié à la direction de la houle

mvh : vitesses due à la houle des noeuds dans le repère cartésien

mgh : accélérations due à la houle des noeuds dans le repère cartésien

whs : Sens des limites : si whs[3*zi] = 0, on est en présence d'un noeud fixe selon z qui ne peut pas bouger selon cette direction alors que si whs[3*zi] > 0, le noeud peut décoller vers le haut pour un effort > 0 et si whs[3*zi] < 0, le noeud peut décoller vers le bas pour un effort < 0.
wh : Maximum des limites (par exemple si wh[3*zi]=-40, le noeud ne peut pas dépasser une profondeur de -40m)

wanoeud : vecteur effort agissant directement sur les noeuds par l'environnement extérieur
wasurf : vecteur effort agissant directement sur les surfaces par l'environnement extérieur et affecté aux noeuds
waelem :  vecteur effort agissant sur les éléments par l'environnement extérieur et affecté aux noeuds
wa : vecteur effort agissant sur les noeuds par l'environnement extérieur et correspondant aux efforts exercés par l'environnement extérieur sur les éléments, sur les surfaces et sur les noeuds directements
waemodif : non utilisé j'ai l'impression
waecontact : non utilisé j'ai l'impression

wae : efforts locaux agissant dans une nappe de filet, un élément, ... (dû à l'elasticité des fils, à la pression interne, ...)
we : raideur et raideur additionnelle dans un élément, une nappe de filet ou un noeud.

ze : matrice raideur

te : Effort tangentiel local dans les éléments
ne : Effort normal local dans les éléments

ETuv : Effort tangentiel local dans les fils des panneaux de filets selon les trois directions et pour les trois sommets des triangles du maillage numérique du filet
ENuv : Effort normal local dans les fils des panneaux de filets selon les trois directions et pour les trois sommets des triangles du maillage numérique du filet
ETlmn : Identique à ETuv mais pour Surf_hexa
ENlmn : Identique à ENuv mais pour Surf_hexa
ETu_ou_v : Efforts hydrodynamiques local exercés de manière tangentiel sur les triangles du maillage numérique du filet. 
Pour cela, on sépare le triangle en trois partie égale avec un sommet dans chaque partie et avec tous les points de ces triangles 
qui sont soumis à des vitesses hydrodynamiques égales entre elle (et égale à celle s'exerçant sur le sommet). On reporte ensuite 
l'effort au sommet contenu dans l'un de ces trois triangles tout en tenant compte de la surface mouillée
ET : Efforts tangentiels local exercés sur les noeuds pour les surfaces (= ETu_ou_v sauf que l'on prend en plus en compte la surface mouillé 
et ETuv ou ETlmn selon que l'on soit pour Surf ou Surf_hexa)
EN : Efforts normaux local exercés sur les noeuds pour les surfaces (= ENu_ou_v sauf que l'on prend en plus en compte la surface mouillé 
et ENuv ou ENlmn selon que l'on soit pour Surf ou Surf_hexa)

Pe : vecteur contenant les efforts dus au poids pour les trois sommets du triangle

kcontact : non utilisé j'ai l'impression
kmodif : non utilisé j'ai l'impression

fixx is  0 -> the noce can move
fixx is  1 -> the node cant move and is at x position defined in .don file
fixx is -1 -> the node cant move and is at x position defined in .sta file
#########################################


//guide du fichier de donnees:

//pour afficher des distances entre noeuds
//OUTS: DIST: TITL:#1 vertical diameter 	(m)#NODG: 39 40 DECI:3
nombre de distance 	: 1
distance numero		: 1
commentaire		: #1 vertical diameter 				(m)#
no noeud global 1	: 39
no noeud global 2	: 40
nombre de decimale	: 3

//pour afficher des efforts sur des noeuds
//OUTS: EFFO: TITL:#Door spread force (N)# NODG: 46 AXE:2 DECI:0 position numero		: 1
nombre d effort 	:			1
effort numero		: 1
commentaire		: #Door spread force 		(N)#
no noeud global		: 46
axe			: 2
nombre de decimale	: 0

//pour afficher des tension dans des elements barres. Element est le no du cable (dans batz info.element type_element)
//extremite globale est le no du noeud global (dans batz info.noeud numero_noeud)
nombre de tension 	: 6
tension numero		: 1
commentaire		: #Tension dans la fune tribord			(N)#
element 		: 27
extremite globale	: 1
nombre de decimale	: 0

//pour afficher des tension dans des elements coulisses
nombre de tension coulisse		:	0

//pour afficher des position de noeuds dans une direction x,y ou z donnee
nombre de position 	: 6
position numero		: 1
commentaire		: #Immersion corde de dos tribord			(m)#
no noeud global		: 17
axe			: 3
nombre de decimale	: 0

//pour sortir la longueur du cable no 2 avec 2 decimales
//OUTS: LENG: TITL:#meridienne 	(m)#ELEM: 2 DECI:3
//la ligne suivante fonctionne le 13 06 2003
//output pour dire qu on veux une sortie
//cable_length pour dire que c est une longueur d element qu on veux afficher
//"" le commentaire est entre "
//2	le numero de l element dans *.don
//3	le nombre de decimales affichees*/
output cable_length "longueur_du_fil_(m)" 2 3

//pour sortir le volume de la structure selon la direction no 3
//output pour dire qu on veux une sortie
//volume_z pour dire que c est le volume calcule selon l axe z
output volume_z

//pour sortir le diametre de la prise
//output pour dire qu on veux une sortie
//catch_diameter pour dire que c est le diametre qu on veux afficher*/
output catch_diameter

//pour afficher le volume de la prise eau comprise
//output pour dire qu on veux une sortie
//catch_volume pour dire que c est le volume qu on veux afficher*/
output catch_volume

//pour sortir l ernegie elastique emmagasinee dans les fils du panneau de filet a mailles losange 2 avec 3 decimales
//OUTS: ENEP: TITL:#meridienne 	(m)#PANN: 2 DECI:3
//la ligne suivante fonctionne le 13 06 2003
//output pour dire qu on veux une sortie
//energy_elastic pour dire que c est une energy elastique qu on veux afficher
//"" le commentaire est entre "
//2	le numero du panneau dans *.don
//3	le nombre de decimales affichees*/
output energy_elongation_diamond "energie elastique du panneau 2" 2 3

//pour sortir l ernegie elastique emmagasinee dans le pliage des fils du panneau de filet a mailles losange 1 avec 4 decimales
output energy_foldind_diamond "energie pliage du panneau 1 (J)" 1 4

//pour sortir l ernegie elastique emmagasinee dans l ouverture des mailles losange du panneau de filet a mailles losange 1 avec 4 decimales
output energy_opening_diamond "energie ouverture du panneau 1 (J)" 1 4

//pour obtenir la forme de l'ellipsoide representant la surface interne de la prise
//renvoie 3 valeurs: radial radius, axial radius et distance du centre de l'ellipse à l extremite du cod-end
output inner_surface

///*pour initialiser la prise en donnant 4 valeurs qui sont dans l'ordre:
//le volume de poisson en m^3,  
//le perimetre du cod-end en m, 
//la taille moyenne des poisson en m^3 
//et la raideur à l'ouverture des mailles en Nm^2*/
//cette procedure prend en compte les plans de symmetrie: 
//si 0 plan de symmetrie tout le volume est affecte
//si 1 plan de symmetrie 1/2 volume est affecte
//si 2 plan de symmetrie 1/4 volume est affecte
//si raideur à l'ouverture des mailles == 0 : PA
//si raideur à l'ouverture des mailles != 0 : PE
input catch 0.580 6.90 0.001 0

//la sortie ecran et fichier donne le diametre maximal de la prise en m
output catch_diameter

//la sortie ecran et fichier donne le volume de la prise en m^3
output catch_volume

//la sortie ecran et fichier donne la longueur du cable (ou element) numero
//n1 (defini dans *.don) avec n2 decimales> valeur donnee en m
output cable_length n1 n2

//lorsqu on veux tourner 2 triangles jointifs
//par exemple si le triangle 5090 a pour sommets 1, 4 et 3 et le triangle 5109 2,3 et 4
//la ligne suivante les transforment en 1, 2 et 3 et 1, 4 et 2
input inversion_triangles 5090 5109

//lorsqu il y a une raideur a l ouverture des mailles definie dans les carateristiques des panneaux de filet
//on peut integrer un angle neutre pour cette raideur attention c est le demi angle entre u et v
//par exemple la ligne suivante donne un angle neutre de 0.31 Rad pour le panneau 1 de mailles losange
input neutral_angle 	1 	0.31
// la raideur à l'ouverture peut être approximée par 6.0 * Surface[elem].EI_flexion / Surface[elem].lgrepos;
//H = Surface[elem].raideur_ouverture;  /*couple = H en  N.m pour 1 radian d ouverture pour un noeud*/
//H = 6.0 * Surface[elem].EI_flexion / Surface[elem].lgrepos;


//mesh opening stiffness and flexion stiffness of twines
//such that U meshes are harder to open (cf phobos, visualisation, UV_vectors)
//For PA EI (N.mm²) = 19.7 + 2.66 diam² (diam en mm)
//For PE EI (N.mm²) = 100 + 14.9 diam² (diam en mm)
//For PE Breizline EI (N.mm²) = 20 + 22.7 diam² (diam en mm)
input EI_flexion 1 0.005655

//si on veux integrer des winchs comme objets de la structure commencer la premierre ligne du fichier de donnee
//par version_2: mais WARNING ca ne marche pas
//la ligne suivante precise qu'il ny a pas de winchs
calcul dans le plan perpendiculaire a z cad coordonnees z cstes : 3
//la ligne suivante precise qu il y a des winchs
version_2 calcul dans le plan perpendiculaire a z cad coordonnees z cstes : 3


//les lignes suivantes donne un exemple de winch cf /data_2004/bouts/crane/deux.don
winch number : 1
winch : 1
winch extremities description no x y z no_type:
1 	0 	2.1 	-10 	1
2 	100 	0 	-10 	3
Raideur traction (N) :			6.0e+4
Raideur compression (N) :		0
Longueur au repos (m) :			220
Masse volumique (kg/m3) :		1025
Diametre hydrodynamique (m) :		0.018
Coefficient de trainee normal :		1.2
Coefficient de trainee tangent :	0.08
ajusting force (N) :			1000
nb barre :				50
type des noeuds interieurs :		2

//si on veux integrer des balles (ou poissons sphèriques et élastiques)
//ajouter version_3 au debut
input balls 3 0.13 0 0 -10 100 2
3	: nb de balles
0.13 	: radius m
0 0 -10	: position initiale en x y et z
100 	: raideur en N/m
2 	: type de la balles une fois née

//si on veux integrer des balles (ou poissons sphèriques et élastiques)
//avec une vitesse initiale
//ajouter version_3 au debut
input balls_2 3 0.13 0 0 -10 100 2 20.0 1.0 2.0
3	: nb de balles
0.13 	: radius m
0 0 -10	: position initiale en x y et z
100 	: raideur en N/m
2 	: type de la balles une fois née
20.0	: ball speed along x
1.0	: ball speed along y
2.0	: ball speed along z

//pour sortir un hystogramme de l'ouverture de maille en degres
//indiquer le nb de panneaux concerne: ci dessous 2
//indiquer les pânneaux concernes: ci dessous 2 et 1
//indiquer le pas de l' hystogramme en degre: ci dessous 5
output opening_angle 2 2 1 5.0 

//pour sortir un hystogramme de l'ouverture de maille en degres par bandes
//indiquer le nb de panneaux concerne: ci dessous 2
//indiquer les pânneaux concernes: ci dessous 2 et 1
//indiquer le pas de l' hystogramme en degre: ci dessous 5
//indiquer le pas de la bande en m a partir du front: ci dessous 1
output opening_angle_stripe 2 2 1 5.0 1.0

//for creating a pressure on a panel of diamond netting without catch use tarp:
//the following leads to a drag on panel 2 of diamond meshes
input tarp 2 

//for creating a pressure on a panel of hexagonal netting without catch use tarp:
//the following leads to a drag on panel 2 of hexagonal meshes
input tarp_hexa 2

//for grid definition
//the following line define the frame of a grid which is
//defined by 6 bars (1st nb) followed by the nb of the bars elements
//../data_2001/grille/catch3
input grid 6 1 2 9 10 7 8

//calculation of the EI value from the material and the diameter
/*PA*/
Panneau[pa].EI_flexion = 2.5 * PI * Panneau[pa].diam_hydro * Panneau[pa].diam_hydro;
/*PE*/
Panneau[pa].EI_flexion = 25.0 * PI * Panneau[pa].diam_hydro * Panneau[pa].diam_hydro;

//automatic creation of link between points if they are at a distance < 
//a certain value. This distance is measured in the plane of the drawing
//in the following all nodes with a distance < 1m are linked
input link 1

//if you want to give the position of 2 panels in place of catch thickness
//indicate as following for the limit between panels 1 and 2
output panels 1 2

//if you want to get the shape of the codend indicate as follow with the nb of panels
//which constitute the codend and the nb of the panels
output meridian 2 1 2 

//if you want to get the shape of the meridian which include the nodes 
//which are on the symmetry plane normal to X axis
output meridian_X 

//if you want to get the shape of the meridian which include the nodes 
//which are on the symmetry plane normal to Y axis
output meridian_Y 

//if you want to get the shape of the meridian which include the nodes 
//which are on the symmetry plane normal to Z axis
output meridian_Z 

//if you want to get the curvilinear length of the codend
//the curvilinear length of the catch and the ratio of theses 2 lengths
//indicate as follow with the number of panels
//which constitute the codend and the numero of the panels
output curvilinear_codend_length 2 1 2 

//if you want to create a spherical limit on certain type of nodes indicate as following: which indicate
//the x y and z coordinates of the sphere, the radius and the stiffness in compression and the stiffness in traction
//indicate also that the type of node involved by this limit is indicated as sens of limit alonz z axis = 2
input spheric_limit 0.0 0.0 -10.0 0.25 100000 100000

//the position of the front in nb of mesh along U direction:
output nb_mesh_front 1 

//the position of the front in nb of mesh along V direction:
output nb_mesh_front 2

//a catch volume for a certain nb of panel. The next exemple gives two catches
//the first  has a volume of 1.0 m3 affected to 2 panels: n° 31 and 32
//the second has a volume of 2.0 m3 affected to 4 panels: n° 31 32 14 and 15
input catch2_volume 1.0 2 31 32
input catch2_volume 2.0 4 29 30 14 15

//output of the drag of the catch in N
output catch_drag

//output of the drag of the nodes in N (floats, dead waights)
output node_drag

//output of the drag of the elements in N (cables, warps, bridles, bars)
output element_drag

//output of the drag of the surfaces in N (diamond, squarre, hexagonal netting)
output surface_drag

//output of the drag on the bottom in N
output bottom_drag

//translate along z of some elements (the same along x and y)
//the following move of 180m along z axis the elements 79 to 152
input add_z_ele 180.0 79 152

//translate along z of some surfaces (the same along x and y)
//the following move of 180m along z axis the netting panels 79 to 152
input add_z_pan 180.0 79 152

//rotate around z of some elements (the same along x and y)
//the following rotate around the point (1.0,2.0) of pi/4 the elements 11 to 17
input rot_z_ele 1.0 2.0 4.0 11 17

//rotate around z of some panels (the same along x and y)
//the following rotate around the point (3.0,2.0) of pi/2 the panels 3 to 8
input rot_z_pan 3.0 2.0 2.0 3 8

//optimization of structure:
optimization 1 is cancelled
optimization 2 is cancelled
optimization 3 nb_step prop						/*drag/S by steps*/
optimization 4 is cancelled
optimization 5 nb_step prop nb_node node[no] dir[no] weighting[no]	/*drag/L by steps*/
optimization 6 nb_step prop						/*drag/S by random*/
optimization 7 nb_step d_mesh   d_obj  precis				/*drag/S by gradient*/
optimization 8 prop_max prop_min prop_multip				/*drag/S by sequentials*/
optimization 9 prop_max prop_min prop_multip       nb_node node[no] dir[no] weighting[no] 	node[no] dir[no] weighting[no]
optimization 10 prop_max prop_min prop_multip				/*nb unstretched twines by sequentials*/
optimization 11 nb_step prop						/*drag/S by steps by modification of cables length*/

//if otptimization is 11 the ratio "structure force along X" divided by the "swept area" is minimized
//with a step of prop of length of cables
//during nb_step steps
//put nombre de distance 			:	0
//    nombre d effort 				:	0
//    nombre de tension 			:	0
//    nombre de tension coulisse		:	0
//    nombre de position 			: 	0
optimization 11 1000 0.01

//if otptimization is 3 the ratio "structure force along X" divided by the "swept area" is minimized
//with a step of prop of the maximal size of the panel
//during nb_step steps
//put nombre de distance 			:	0
//    nombre d effort 				:	0
//    nombre de tension 			:	0
//    nombre de tension coulisse		:	0
//    nombre de position 			: 	0
optimization 3 nb_step prop

//if otptimization is 12 the ratio "structure force along X" divided by the "swept area" is minimized
//with a step of prop of the maximal size of the panel and the length of the ropes
//during nb_step steps
//put nombre de distance 			:	0
//    nombre d effort 				:	0
//    nombre de tension 			:	0
//    nombre de tension coulisse		:	0
//    nombre de position 			: 	0
optimization 12 nb_step prop

//Hiden elements
//with the following 4 elements are hiden (elements 9 10 11 12)
output no_visible_element 4 9 10 11 12

//Hiden panels
//with the following 4 surfaces are hiden (surfaces 9 10 11 12)
output no_visible_surface 4 9 10 11 12

//addition of cage
//addition of a cage with its net depending on mechanical properties respectively : diametre (12m);position of the center (x,y) (139m,139m);
//number of segmentations = number of lateral panels (16); distance between the two floating circles(0.7m); height of the floating support(1m);
//depth of the net(6.5m); size of the mesh(0.025m);diametre of the two floating circles(0.25m);epaisseur of tube(0.015m);
//density of tube(950kg/m^3); "immersion" or "floating" position of the cage.
//NB : add "number of segmentation" + 1 panels (needed to be declared in the .don file)
//NB : add 8 * "number of segmentation" elements (needed to be declared in the .don file)
//attention orientation du dessin doit etre tel que perpendiculaire a l axe des z soi:
//calcul dans le plan perpendiculaire a z cad coordonnees z cstes : 3 
input add_cage 12 139 139 16 0.7 1 6.5 0.025 0.25 0.015 950 immersion

//addition of predator cage
//addition of a cage with its net depending on mechanical properties respectively : diametre (13.4m); diametre of the ballast (15m); position of the center (x,y) (139m,139m);
//number of segmentations = number of panels (16); distance between the two floating circles(0.7m); depth of the net(10m); 
//size of the mesh(0.04m); diametre of the two floating circles(0.25m);epaisseur of tube(0.015m);
//density of tube(950kg/m^3);
//NB : add "number of segmentation" + 1 panels (needed to be declared in the .don file)
//NB : add 4 * "number of segmentation" elements (needed to be declared in the .don file)
//attention orientation du dessin doit etre tel que perpendiculaire a l axe des z soi:
//calcul dans le plan perpendiculaire a z cad coordonnees z cstes : 3 
input add_filet_pred 13.4 15 139 139 16 0.7 10 0.04 0.25 0.015 950


//to accelerate the convergence
input Auto_convergence

//in order to have convergence parameters specifiquely for the file
//add the following line to have a Relaxation of 1 a Periodeimpression of 10 and an added stiffness of 100 N
input convergence_parameters 1 10 100

//in case of the bottom move with the water
input moving_bottom

//for the optimization  to take into account the symmetry and to allow the modification in the other direction of the symmetry
//for example the following means that the symmetry along Y cartesian axis is also along meshing U that means that the
//the displacement along the axis U is forbidden for nodes with symy for 20 panels (from 2 to 34).
//to verify if it is along U or V you have to draw "axe_T90" in phobos menu "visualisation" the lines are along V axis
//that means that if these lines are normal to the symmetry plane you will have something like symx_V symy_V or symz_V
//if these lines are parallel to the symmetry plane you will have something like symx_U symy_U or symz_U
input symy_U 20 2 3 4 5 6 7 8 9 10 11 25 26 27 28 29 30 31 32 33 34

/*to avoid problem when a bar is parallel and near the free surface the bars have their drag and floatability calculated 
such as the volume of the bar
is split between each extremity. The node is a cube of side = pow(volum_elem /2,1/3). The drag coef is calculated
in order to have a similar drag: cd  = Element[zg].cdnormal*Element[zg].lgrepos*Element[zg].diametrehydro/(lonx*lonz);
it is used in dyna2 but maybe needed to be used in unix_2004. This is a default behaviour
if input elem_noeud the drag and floatability is calculated along all the bar*/
//this not compatible with input tab_drag_filt 
input elem_noeud 15 32
not recommended

/*convertion ps to jpg*/
convert -density 300 ../data_2001/chalut/sardone/nerz_5.ps ../data_2001/chalut/sardone/nerz_5f.png

/*memory leaks*/
1) Include mcheck.h header file.
2) Place mtrace() in the first line of main(). mtrace will start tracing memory from this point.
3) Place muntrace() in the end of main() to stop tracing.
4) At command promt type export MALLOC_TRACE=mtrace.log to save output in mtrace.log file.
5) Compile and run the program again.

//output of the drag of each type of surfaces in N (diamond, squarre, hexagonal netting)
//which is equivallent to the drag of each panel of netting
output panel_drag

//output of the drag of each triangle in N (diamond, squarre, hexagonal netting) and the amplitude of the hydrodynamics force in N
output triangle_drag

//in optimisation process to avoid modification along U direction for node use
//input lock_U number_of_node panel_number corner_number
//the following means that there are two nodes locked along U. They are corner 2 of panel 1 and corner 3 of panel 1
input lock_U 2 1 2 1 3

//in optimisation process to avoid modification along V direction for node use
//input lock_U number_of_node panel_number corner_number
//the following means that there are three nodes locked along V. They are corner 1 2 and 3 of panel 1
input lock_V 3 1 1 1 2 1 3

//in optimisation process to avoid modification along U direction for entire panels
//input lock_panel_U number_of_panel panel_number ...
//the following means that there are two 4 panels which are locked along U. They are corner panel 1 2 3 and 4
input lock_panel_U 4 1 2 3 4

//in optimisation process to avoid modification along V direction for entire panels
//input lock_panel_V number_of_panel panel_number ...
//the following means that there are two 4 panels which are locked along V. They are corner panel 1 2 3 and 4
input lock_panel_V 4 1 2 3 4

//define the nb of meshes involved in the seam by panel
//diamond_seam_element int_number_panel float_number_meshes
//the following line define a seam of 4.5 meshes around the panel 5
diamond_seam_element 5 4.5

//add sphere floats along a cable element, the drag coef of sphere is 0.6
//the following line Add on element E_numero, S_Nb spheres of diameter S_Diam m of S_Float N of floattability
//sphere_element E_numero S_Nb S_Diam S_Float
the following line Add on element 14, 5 spheres of diameter 0.2 m of 8.5 N of floattability
input sphere_element 14 5 0.2 8.5

//add sphere floats along a cable element, the drag coef of sphere is 0.6
//the following line Add on element E_numero, S_Nb spheres of diameter S_Diam m of S_Float N of floattability, the length of the element is S_length
//sphere_element2 E_numero S_Nb S_Diam S_Float S_length
the following line Add on element 14, 5 spheres of diameter 0.2 m of 8.5 N of floattability the elemnt 14 is expected of length 5.1m
input sphere_element2 14 5 0.2 8.5 5.1

//optimization of structure
//if optimization is 5 the ratio "structure force along X" divided by a "swept length" is minimized
//with a step of prop of the maximal size of the panel during nb_step steps
//the swept length is defined on nb_node (int)
//this length is the sum of weighted coordinate of the nodes
//for each node(int) the direction dir 
//the direction dir is 1 (2,3) for x (y,z) axis
optimization 5 nb_step prop nb_node node[no] dir[no] weighting[no]

//optimization of structure random
//if optimization is 6 the ratio "structure force along X" divided by a "swept area" is minimized
//for a number of case (nb_step) which are a random value around the initial coordinates
//these random value are calculated with a maximal proportion around the initaila value (prop)
optimization 6 nb_step prop

//optimization of structure
//if optimization is 7 the ratio "structure force along X" divided by a "swept area" is minimized
//for a number of case (nb_step) in which the direction of displacement is calculated with the gradient
//this gradient is calculated by finite difference with delta_displacement (d_mesh), once the direction is found
//the amplitude of the displecement vector is calculated with an expected decrease of the objective (d_obj)
//once the amplitude is found this amplitude is multipled by 2 or divided by 2 up to find the minimum
//at a precision on the objective (precis)
optimization 7   nb_step d_mesh   d_obj  precis
optimization 7   100     0.10     1.0    0.001

//if otptimization is 8 the ratio "structure force along X" divided by the "swept area" is minimized
//with a step of prop of the maximal size of the panel which varies from prop_max to prop_min by prop_multip
//the exemple the prop will be 0.64 0.32 0.16 0.08 0.04 0.02 0.01 (each time multiplied by 0.5 from 0.64 to 0.01)
//put nombre de distance 			:	0
//    nombre d effort 				:	0
//    nombre de tension 			:	0
//    nombre de tension coulisse		:	0
//    nombre de position 			: 	0
optimization 8 prop_max prop_min prop_multip
optimization 8 0.64 0.01 0.5

//optimization of structure
//if optimization is 9 the ratio "structure force along X" divided by a "swept length" is minimized
//with a step of prop of the maximal size of the panel which varies from prop_max to prop_min by prop_multip
//the exemple the prop will be 0.64 0.32 0.16 0.08 0.04 0.02 0.01 (each time multiplied by 0.5 from 0.64 to 0.01)
//the swept length is defined on nb_node (int)
//this length is the sum of weighted coordinate of the nodes
//for each node(int) the direction dir 
//the direction dir is 1 (2,3) for x (y,z) axis
//the exemple the "swept length" is 0.5 times the coordinate y(2) of node 25 plus 0.5 times the coordinate y(2) of node 26
optimization 9 prop_max prop_min prop_multip       nb_node node[no] dir[no] weighting[no] 	node[no] dir[no] weighting[no]
optimization 9 0.64     0.01     0.5               2       25       2       0.5             	26       2       0.5

//if otptimization is 10 the nb of twines with a negative tension is minimized
//this is expected to limit the folding
//with a step of prop of the maximal size of the panel which varies from prop_max to prop_min by prop_multip
//the exemple the prop will be 0.64 0.32 0.16 0.08 0.04 0.02 0.01 (each time multiplied by 0.5 from 0.64 to 0.01)
//put nombre de distance 			:	0
//    nombre d effort 				:	0
//    nombre de tension 			:	0
//    nombre de tension coulisse		:	0
//    nombre de position 			: 	0
optimization 10 prop_max prop_min prop_multip
optimization 10 0.64 0.01 0.5

//reduction of the current on netting panel
//the following means that the current on panel 7 is 65% of the nominal current
input current_reduction 7 0.65

//Hiden elements which touch the window defined by
//minx maxx miny maxy minz maxz in phobos
output no_visible_element_window 140.5 270 0 270 -1000 1000

//to take into account the wind 
//the following means that the wind speed is 0 m/s and the direction is 270 deg relatively to X axe
//the effect is only on node but not on element and not on netting
input wind 0 270

//calculation of the objective for a variation of only two parameters
//the last line in name_of_file.don means that 
//the first  parameter from panel 1, corner 6, direction 2 (V), plage of variation -+1,   step of variation 1
//the second parameter from panel 3, corner 7, direction 1 (U), plage of variation -+1.5, step of variation 1.5
//in this case there are 9 calculations: for parameters 1: -1, 0, +1 and for parameter 2: -1.5, 0 and +1.5
//the result is in name_of_file.res
input two_parameters 1 6 2 1 1     3 7 1 1.5 1.5

//fish repartition used by optimization ?
//h1 is the height 1 (relatively to the bottom) where there is the repartition r1, h1 is in m, r1 is the ratio of fish on water at h1
//the same for h2 and r2
//there is a linear variation betwwen h1 and h2 and the ratio is always >= 0, that means that there is a linear 
//relation upto the repartition = 0.0
input target_repartition h1 r1 h2 r2
input target_repartition 3 0     0 0.01
//not finished

//for calculation of value which enter the trawl
//the following line means that at -90m of depth the value is 1 and the value at -85 is 0.5
//there is a linear variation of value between this two points and the value is zero elsewhere
output value -90.0 1 -85.0 0.5

//to input several ropes separeted by the same distance
//input rope_X (rope_Y, rope_Z) nb_of_ropes copied_rope distance_between_ropes
//the following line means that there are 14 ropes (and not 15!)
//identical to rope 4 and separated of 0.5m along axe X (Y, Z)
//that means that 13 ropes are added. They are ropes 4, 5, 6, 7 ... 16, 17.
input rope_X 14 4 0.5

//to calculate the distance along x axis between two cables 
//that gives the minimum, maximum and mean distance between nodes of first cable
//to cable 2. The following line is for cable 2 and cable 9
output recouvrement_x 2 9

//to impose the distance between two cables in nerzh
//with the minimum, distance between nodes of first cable
//to cable 2. The following line is for cable 2 and cable 9 and the limit is 7.5m
output recouvrement_x_limit 2 9 7.50

//create dependance of node coordinates to two another nodes
//in the following line node 6 of panel 13 is link to node 5 of panel 13 by a proportion of 0.9375 (15/16) 
//and to node 1 of panel 13 by a proportion of 0.0625 (1/16) 
//coordinates x, y, z, U and V are dependant
input connect_panel_node 13  6 13 5 0.9375 13 1 0.0625

//in nerzh_2. to link displacement of nodes together
//The line input link_movement_UU slave_panel slave_node master_panel master_node weight
//is such that the U displacement of slave_node of slave_panel is weight times the U displacement of master_node of master_panel
//the following line is such that the U displacement of node 2 (master_node)  of panel 1 (master_panel) will lead to the same displacement of 
//node 3 (slave_node) of pane 1 (slave_pane)
input link_movement_UU pa_slave no_slave pa_master no_master weight
input link_movement_UU 1 3 1 2 1.0


//in nerzh_2. to link displacement of nodes together
//The line input link_movement_VV slave_panel slave_node master_panel master_node weight
//is such that the V displacement of slave_node of slave_panel is weight times the V displacement of master_node of master_panel
//the following line is such that the V displacement of node 2 (master_node)  of panel 1 (master_panel) will lead to the same displacement of 
//node 3 (slave_node) of pane 1 (slave_pane)
input link_movement_VV 1 3 1 4 1.0



// Addition of links between the cages and the mooring lines. 
// 3 types of links are for now definite :
// - 1 : simple link 
// -> Parameters : coord (x, y, z) of the linking node, relative position of the counterweight (0 means the counterweight is 
// on the linking node, 1 : on the cage, 0.5 in the middle of the link, 0.33 in one on third of the link, ...), position z of the 
// counterweight, number of the node on the cage where the link is connected (if the number of panels is for example 16, 
// the node 16 is the node of the cage where x is minimum (and y equals to zero) and the following numbers are counted in the 
// trigonometric sense).
//
// - 2 : double link 
// -> Parameters : coord (x, y, z) of the linking node, relative position of the counterweight for the first link, position z of the 
// counterweight for the first link, number of the node on the cage where the first link is connected, relative position of the 
// counterweight for the second link, position z of the counterweight for the second link, number of the node on the cage where the 
// second link is connected.
//
// - 3 : link in Y 
// -> Parameters : : coord (x, y, z) of the linking node, relative position of the counterweight, position z of the counterweight, number 
// of the node on the cage where the first link is connected, relative position of the fork, position z of the fork, number of the node 
// on the cage where the first link of the fork is connected, number of the node on the cage where the second link of the fork is connected
//
//
// Parameters : Diameter of the cage (14m), coord (x,y) of the center of the cage (141.16,141.16), number of lateral panels in the cage (16)
// Type of the first link with its parameters (cf previous description)
// Type of the second link with its parameters (cf previous description)
// Type of the third link with its parameters (cf previous description)
// Type of the fourth link with its parameters (cf previous description)
input accroche 14.00 141.16 141.16 16 3 126.71 126.00 -6.00 0.3300 -6.00 7 0.6600 -3.00 15 13 3 155.29 126.00 -6.00 0.3300 -6.00 7 0.6600 -3.00 11 9 3 155.29 156.00 -6.00 0.3300 -6.00 7 0.6600 -3.00 7 5 3 126.71 156.00 -6.00 0.3300 -6.00 7 0.6600 -3.00 3 1


// Addition of a line constituted with a principal line and eventually vertical elements as ramifications (to add for exemple counterweights 
// or buoys). 
// Parameters : coord of the first node (x, y, z), type of the first node, length of the element between the first and the
// second element, coord of the second node (x, y, z), type of the second node, length of the element between the second and the third 
// element, ... , coord of the last node (x, y, z), type of the last node. A vertical ramification is automatically recognized when the 
// coord (x,y) are the same than the previous node. 
input ligne_tot 0.00 126.00 -40.00 1 20.00 19.05 126.00 -40.00 2 103.00 117.18 126.00 -6.00 2 5.00 117.18 126.00 -1.00 3 5.00 121.95 126.00 -6.00 2 2.00 121.95 126.00 -8.00 5 5.00 126.71 126.00 -6.00 2 5.00 126.71 126.00 -1.00 3 15.00 141.00 126.00 -6.00 2 2.00 141.00 126.00 -8.00 5 15.00 155.29 126.00 -6.00 2 5.00 155.29 126.00 -1.00 3 5.00 160.05 126.00 -6.00 2 2.00 160.05 126.00 -8.00 5 5.00 164.82 126.00 -6.00 2 5.00 164.82 126.00 -1.00 3 103.00 262.95 126.00 -40.00 2 20.00 282.00 126.00 -40.00 1


// Addition of a line constituted of a principal line and eventually vertical elements as ramifications (to add for exemple counterweights 
// or buoys). 
// Parameters : coord x of the nodes, coord y of the nodes, coord z of the nodes, type of the nodes, length of the element between nodes
input ligne_ordre 0 20 116.16 116.16 121.16 121.16 126.16 126.16 141.16 141.16 156.16 156.16 161.16 161.16 166.16 166.16 262.32 282.32 126.16 126.16 126.16 126.16 126.16 126.16 126.16 126.16 126.16 126.16 126.16 126.16 126.16 126.16 126.16 126.16 126.16 126.16 -40 -40 -6 -1 -6 -8 -6 -1 -6 -8 -6 -1 -6 -8 -6 -1 -40 -40 1 2 2 3 2 5 2 3 2 5 2 3 2 5 2 3 2 1 20 110 5 5 2 5 5 15 2 15 5 5 2 5 5 110 20


// Modification of the caracteristics of the materials of an element
// Parameters : Number of the element (1), Raideur en traction (100000000), Raideur en compression (10), density (7800 in kg.m-3),
// coeff de trainee normal (1.2), coeff de trainee tangent (0.08)
input materiau_elem 1 100000000 10 7800 0.05 1.2 0.08                  


// Modification of the number of bars in an element 
// Parameters : Number of the element, number of bars in the element
input nb_barre 159 10


// Allow to print the volume before and after the static calcul for a cage definite with add_chapeau (WATCH OUT : not with add_cage)
// Parameters : Number of the first panel which constitute the cage, number of the last panel which constitute the cage 
output cage_volume 1 18

//allow to display the tension vector in a bar
// the result is such as 
//tension bar 73 vector tension 8783.999339 -1635.021343 -222.847294 tension 8937.650703 vector direction 0.982809 -0.182936 -0.024934 
output vector_tension_bar 73

//in order to visualise without the symmetrical parts in batz
output no_visible_symmetry

//to turn a meshing of a panel in order to have a side parralell to U twines ,and the result is written on the command window
//the result has to be copied in the don file to take into account this turning
//the following line indicates that the panel 1 will be turned to have side 3 parrallel to U twine
//WARNING: sometimes taht turns in the right directionb sometimes in the wrong one: 
//in this last case change base1(alpha,3,0.0,3,3,v1); by base1(-alpha,3,0.0,3,3,v1); in chargement_don.c in phobos_2005 and  type make
output rotation_panel_U 1 3

//plan   design
//in order to draw the symmetrical plan for the panel of netting uou have to indicate the direction of the drawing
// in the example the z axis (3), and you have to indicate the position of the symmetry plan for each panel of diamond netting
output symmetry_plan 3 10.61 10.61 10.61 10.61 10.61 10.61 10.61 10.61 33.94 33.94 33.94 33.94 33.94 33.94

//plan design
//in order to draw horizontal lines which delimate the zone of the diamond panels
//you have to indicate the direction of the drawing in the example is z axis (3), the number of lines (20), 
//and for each line the beginning of the line defined 
//by a panel (1) and a corner (1) and by the end of the line (-20m)
output line_plan 3 20 	1 1  -20 	1 2  -20  	2 1 -20 	2 4 -20 	3 2 -20 4 2 -20 5 2 -20 6 2 -20 7 2 -20 8 2 -20 8 3 -20 13 4 60 13 5 60 13 2 60 14 1 60 14 3 60 9 4 60 10 4 60 11 4 60 12 4 60


//plan design
//in order to indicate the heigth of parts of panel of diamond netting, you have to indicate the direction
//of the drawing in the following example it is normal to z axis (3), the number of heigths indicated (18)
//the heights by the number of the panel (1) the two corners (1 & 2) the direction of meshing (2 indicates V direction)
//and the position of this indication (-8m)
output height_plan 3 18 	1 1 2 2 -8  1 2 3 2 -8 	2 4 5 2 -8	2 3 4 2 -8	3 2 3 2 -8	4 2 3 2 -8	5 2 3 2 -8		6 2 3 2 -8	7 2 3 2 -8	8 2 3 2 -8	13 4 5 2 59	13 2 5 2 59	14 1 4 2 59	14 1 2 2 59	9 2 3 2 59	10 2 3 2 59	11 2 3 2 59	12 2 3 2 59

//plan design
//in order to define the limits of the drawing you have to indicate minx maxx miny maxy (-20 70 15 75)
output minmax_plan -20 70 15 75

//plan design
//in order to indicate the width in number of meshes, you have to indicate the direction of the drawing
//in the following example the drawing is along to z axis (3)
//the number of widths (4), the panel (1), the 2 corners (3 & 4) the meshing direction (1 indicate U direction);
//the vertical position relatively to the barycentre of the two corners (0.3m)
output width_plan 3 4	1 3 4 1 0.3	2 5 1 1 -0.8	13 1 2 1 0.3	14 4 5 1 -0.8

//plan design
//in order to indicate the width in number of meshes in case of symmetry plan, you have to indicate the direction of the drawing
//in the following example the drawing is normal to z axis (3)
//the number of widths (22), the panel (2), the 2 corners (3 & 2) the meshing direction (1 indicate U direction);
//the vertical position relatively to the first corner (0.3m)tal width taking into account the symmetry.
//this value is the to
output width_symmetry_plan 3 22	2 3 2 1 0.3	3 1 2 1 -0.8	3 4 3 1 0.3	4 1 2 1 -0.8	4 4 3 1 0.3	5 1 2 1 -0.8	5 4 3 1 0.3	6 1 2 1 -0.8	6 4 3 1 0.3	7 1 2 1 -0.8	7 4 3 1 0.3	8 1 2 1 -0.8	8 4 3 1 0.3	14 2 3 1 0.3	9 2 1 1 -0.8	9 3 4 1 0.3	10 2 1 1 -0.8	10 3 4 1 0.3	11 2 1 1 -0.8	11 3 4 1 0.3	12 2 1 1 -0.8	12 3 4 1 0.3	

//plan design
//in order to indicate the cutting of panel side
//you have to indicate the number of panel cutting, in the following example (9)
//the panel (1) the side (2) which is indicated by the first corner of the side in this example the side is between the corners 2 & 3.
output panel_cutting 9 	1 2 	1 4	2 1	2 4	13 2	13 3 	13 4	14 3	14 7

//plan design
//in order to indicate the length of cables
//you have to indicate the number of displayed cables, in the following example (5)
//and the list of cables.
output plan_cable 	5 	3 4 5 6 7


//in this case the graphics is in black
output black_drawing

//to calculate the intersection of the netting with a plan defined by a node (X0,Y0, Z0) and a normal (Xv, Yv, Zv)
output plan_cutting X0 Y0 Z0 Xv Yv Zv

//in case of optimisation on cables length (optimization type 11)
//some cable length could be fixed (not variable) in this case use input lock_element_length
//in the following line there are 36 cables which are not involved in the optimisation
input lock_element_length 36 13 14 15 16 17 18 19 20 21 26 27 22 23  29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51


//In case of optimisation on cables length  (optimization type 11)
//some cables could have their length proportional to the length of an another cable
//in the following line the length of cable 28 will be proportional the the length of cable 52
//that means that if the length of cable 52 increase of 10% the length of the cable 28 wil increase of the ratio (10%)
input lock_2_element_length 28 52


//the default water density is 1025 kg/m³
//to change use the following line in which the new value is 1000 kg/m³
input water_density 1000

//in order to create the file *.hyd which contains the nodes positions along x y z and the hydrodynamic forces on these points along x y and z
output hydro_forces

//in case of the hydrodynamic forces on diamond netting is calculated with Morison formulations modified by Landweber and Richtmeyer use input drag_forces_type 1
//in case of the hydrodynamic forces on diamond netting is calculated with Morison formulations modified by Zhan use input drag_forces_type 2
//in case of the hydrodynamic forces on diamond netting is calculated with drop pressure formulations defined by Barry O'Neill use input drag_forces_type 3
//in case of the hydrodynamic forces on diamond netting is calculated with Aarnes formulations use input drag_forces_type 4
input drag_forces_type 1

//in case of no calculation of of the intersection of triangular elements of diamond netting with symmetry plan use Filiere.cut_plan_symmetry = 0 which is the default value
//in case of calculation of of the intersection of triangular elements of diamond netting with symmetry plan X use input cut_plan_symmetry 1
//in case of calculation of of the intersection of triangular elements of diamond netting with symmetry plan Y use input cut_plan_symmetry 2
//in case of calculation of of the intersection of triangular elements of diamond netting with symmetry plan Z use input cut_plan_symmetry 3
//in case of calculation the number of points is given, the position x y z of the two vertex of the triangular element on the symmetry plan and the angle between twines of the triangular element is recorded
input cut_plan_symmetry = 2

in case of a catch outside of water the force of this catch is due to the gravity
//and the density of the catch in kg/m^3
//in the following line the density of the catch is 1000kg/m³
input catch_density 1000

//in case of dynamic. reduction of cable length.  indicate the number of the cable (13), the speed of reduction in m/s (1.5)
//the length is the unstrectched length. the extremity of the cable by which the cable is reduced (2). The limit of length of the (1.1m) and the time at which reduction statrs (30s)
//in the following example the cable 13 is reduced at a speed of 1.5m/s by its extremity 2, the limit of length of the cable is 1.1m and it starts to reduce at 30s.
input hauling_cable 13 1.5 2 1.1 30.0

//in case of dynamic. reduction of cable length.  indicate the number of the cable (13), the extremity of the cable by which the cable is reduced (2).
//the times at which the cable begins to reduce (0.0) the times at which the cable ends to reduce (1000.0)
//the speed at which the cable begins to reduce (1.5) the speed at which the cable ends to reduce (1.5)
//input hauling_cable2 NO_cable NO_extremity Begining_times End_times Begining_speed End_speed
input hauling_cable2 13 2 0.0 1000.0 1.5 1.5

//in case of dynamic. reduction of cable length.  indicate the number of the cable (13), the extremity of the cable by which the cable is reduced (2) that means where is the drum.
//the minimal (0.50) and the maximal (25.0) length of bars of the cable the number (4) of times in the times table the table of times (0.0 10 1990.0 2000)
//the table of hauling speed (0 -1 -1.0 0)
input hauling_cable3 13 2 0.50 25.0    4 0.0 10 1990.0 2000 0 -1 -1.0 0
//be careful in case of shooting (hauling speed < 0) verify that the length of the cable is close to the number of bars by the minimal length of bars

//in case of dynamic. reduction of cable length.  indicate the number of the cable (15), the minimal (0.50) and the maximal (50.0) length of bars of the cable
//the number (2) of times in the times table, the table of times (10.0 1495), the table of hauling speed (1.0 1.0), the extremity by which the bars are reduced (2 2)
input hauling_cable4   15 0.50 50.0 2 
10.0	1495  
1.0	1.0 
2	2
//another example: with 12 elements in the table
input hauling_cable4   14 0.010 25.0054 12
502.5    	621.05   	858.15   	1095.25   	1332.35   	1569.45  	1806.55  	2043.65 	2280.75  	2517.85  	2754.95  	2873.5 
0.3280915  	0.4192035  	0.6014275  	0.6476359 	0.7226532  	0.8624705  	1.0208409 	1.1929073 	1.4543323  	1.8277355  	1.8187668  	1.8142825
2 		2 		2 		2 		2 		2 		2 		2 		2 		2 		2		2

//in case of dynamic. reduction of cable length.  indicate the number of the cable (15), the minimal (10.0) and the maximal (1000.0) length of the cable
//the number (2) of times in the times table, the table of times (10.0 1495), the table of hauling speed (1.0 1.0), the extremity by which the bars are reduced (2 2)
input hauling_cable6   15 10.0 1000.0 2 
10.0	1495  
1.0	1.0 
2	2


//in case of dynamic. reduction of cable length.  indicate the number of the cable (14), the minimal (0.010) and the maximal (25.0054) length of bars of the cable
//the number (12) of times in the times table, the table of times (12 reals), the table of mean hauling speed (12 reals), 
//the table of standard deviation of hauling speed (12 reals) and the extremity by which the bars are reduced (12 integers). The speed value will use the mean and
//the standar deviation using normal distribution
input hauling_cable5   14 0.010 25.0054 12
502.5    	621.05    	858.15    	1095.25    	1332.35    	1569.45    	1806.55    	2043.65      	2280.75    	2517.85    	2754.95    	2873.5  
-0.3280915  	-0.4192035  	-0.6014275  	-0.6476359  	-0.7226532  	-0.8624705    	-1.0208409  	-1.1929073  	-1.4543323  	-1.8277355  	-1.8187668  	-1.8142825  
0.3019747    	0.3019747    	0.1633399    	0.2024948    	0.2927417    	0.3270395      	0.3019046    	0.3741510    	0.4132590    	0.4101268    	0.4664947    	0.4664947  
2 		2 		2 		2 		2 		2 		2 		2 		2 		2 		2 		2


//in case of dynamic. Introduce a speed on a node type. In the following lines the node type 1 is modified such as
//   0.0 s the speed is 1.0 0.0 0.0 m/s along x y and z axis 
//1000.0 s the speed is 1.0 0.0 0.0 m/s along x y and z axis 
//input speed_type_node node_type begining_times end_times beginning_vx end_vx beginning_vy end_vy beginning_vz end_vz 
input speed_type_node 1 0.0 1000.0 1.0 1.0 0.0 0.0 0.0 0.0

//another example
input speed_type_node2  1 12	
0.0  		143.675 	431.025   	718.375  	1005.725  	1293.075  	1580.425  	1867.775 	2155.125 	2442.475 	2729.825 	2873.5    
-0.9632337267	-0.9110366597	-0.806642243	-0.6662613237	-0.4400708751	-0.3270213299	-0.3273365582	-0.3306063613	-0.3460065813	-0.4000012552	-0.7291627145	-0.8937435149
0 		0 		0 		0 		0 		0 		0 		0 		0 		0 		0 		0 
0 		0 		0 		0 		0 		0 		0 		0 		0 		0 		0 		0 


//in case of dynamic. Introduce a speed on a node type. In the following lines the node type 1 is modified such using a time table of 12 values
//followed by the times (12 reals),  the mean amplitude of speed in XoY plane (12 reals), the direstion of speed relatively to X axis (12 reals),
//the standard deviation of amplitude of speed (12 reals). The actual amplitude of speed is calculaded ussuming a normal distribution using for each
//time the mean and the standard deviation.
input speed_type_node3  1 12	
0.0    	143.675    	431.025    	718.375    	1005.725    	1293.075    	1580.425    	1867.775      	2155.125    	2442.475    	2729.825    	2873.5  
0.9632338    	0.9110366    	0.8066422    	0.6662613    	0.4400709    	0.3270213    	0.3273366    	0.3306063    	0.3460066      	0.4000012    	0.7291627    	0.8937435  
180 		180 		180 		180 		180 		180 		180 		180 		180 		180 		180 		180 
0.6055734    	0.6055734    	0.3139947    	0.2996304    	0.2188326    	0.193321    	0.1867865    	0.1704992    	0.2725999 	0.2172065    	0.3734596    	0.3734596  


//in case of dynamic. Introduce a speed on a node type. In the following the node type 1 is modified such as
//the number (13) of times in the times table, 
//the times table     (0 10 490 500 510 990 1000 1010 1490 1500 1510 1990 2000)
//the table of speedx (0  1   1   0   0   0    0   -1   -1    0    0    0    0)
//the table of speedy (0  0   0   0   1   1    0    0    0    0   -1   -1    0)
//the table of speedz (0  0   0   0   0   0    0    0    0    0    0    0    0)
//interpolation for the other tmes
input speed_type_node2  1 13 	
0 10 490 500 510 990 1000 1010 1490 1500 1510 1990 2000
0  1   1   0   0   0    0   -1   -1    0    0    0    0	
0  0   0   0   1   1    0    0    0    0   -1   -1    0
0  0   0   0   0   0    0    0    0    0    0    0    0

//input nb of node coordinates where the speed is given in the file  *.fos
// nb_of coordinates numero_coordinate speed_along
speed_type_node4
//in the fos file, there are 6 speeds: 	0.0 along x of node 1, 
					0.0 along y of node 1, 
					0.0 along z of node 1, 
					1.0 along x of node 2, 
					0.0 along y of node 2, 
					0.0 along z of node 2, 
6
1 0.0
2 0.0
3 0.0
4 1.0
5 0.0
6 0.0

//in order to introduce the flexion stiffness in cable use the following line
//in which the cable 13 has an EI value of 12.4 N.m²
input EI_flexion_cable 13 12.4

//in order to change the type of node depending on its position:  
//in the following nodes with X value > 14.0 has now the type 1
input type_noeud_XYZ_SUPINF 1 14.0 1

//in order to change the type of node depending on its position:  
//in the following nodes with X value < 14.0 has now the type 1
input type_noeud_XYZ_SUPINF 2 14.0 1

//in order to change the type of node depending on its position:  
//in the following nodes with Y value > 14.0 has now the type 1
input type_noeud_XYZ_SUPINF 3 14.0 1

//in order to change the type of node depending on its position:  
//in the following nodes with Y value < 14.0 has now the type 1
input type_noeud_XYZ_SUPINF 4 14.0 1

//in order to change the type of node depending on its position:  
//in the following nodes with Z value > 14.0 has now the type 1
input type_noeud_XYZ_SUPINF 5 14.0 1

//in order to change the type of node depending on its position:  
//in the following nodes with Z value < 14.0 has now the type 1
input type_noeud_XYZ_SUPINF 6 14.0 1

//in order to change the type of node depending on its position:  
//in the following nodes with X value > 14.0 and < 15.0 has now the type 1
input type_noeud_XYZ_SUPINF 7 14.0 15.0 1

//in order to change the type of node depending on its position:  
//in the following nodes with Y value > 14.0 and < 15.0 has now the type 1
input type_noeud_XYZ_SUPINF 8 14.0 15.0 1

//in order to change the type of node depending on its position:  
//in the following nodes with Z value > 14.0 and < 15.0 has now the type 1
input type_noeud_XYZ_SUPINF 9 14.0 15.0 1

//in order to change the type of node depending on its position:  
//in the following nodes with X value > 14.0 and < 15.0 and Y value > 16.0 and < 17.0 has now the type 1
input type_noeud_XYZ_SUPINF 10 14.0 15.0 16.0 17.0 1

//in order to change the type of node depending on its position:  
//in the following nodes with Y value > 14.0 and < 15.0 and Z value > 16.0 and < 17.0 has now the type 1
input type_noeud_XYZ_SUPINF 11 14.0 15.0 16.0 17.0 1

//in order to change the type of node depending on its position:  
//in the following nodes with Z value > 14.0 and < 15.0 and X value > 16.0 and < 17.0 has now the type 1
input type_noeud_XYZ_SUPINF 12 14.0 15.0 16.0 17.0 1

//in order to change the type of node depending on its position:  
//in the following nodes with X value > 14.0 and < 15.0 and Y value > 16.0 and < 17.0 and Z value > 18.0 and < 19.0 has now the type 1
input type_noeud_XYZ_SUPINF 13 14.0 15.0 16.0 17.0 18.0 19.0 1

//to be sure that the mesh opening by panel of netting is open uniformely in phobos
input uniform_meshing

//to be sure that the mesh opening by panel of netting is open uniformely in phobos
//in the following line the mesh opening of panel 8 is calculated based on the mesh opening defined by the triangle 2 3 4
input uniform_meshing2 8 2 3 4

//to be sure that the mesh opening by panel of netting is open uniformely in phobos
//the following line indicates that the panel of netting 13 is defined relatively to its point 1
//such as the U twines are 0.17m along x axis and V twines are 0.09m along z axis
input uniform_meshing3 13 1     0.17 0.00 0.00     0.00 0.00 0.09

//In case of 2 bars are connected in flexion bar1 & bar2
//the following decommented line indicates that bar1 is connected with bar2
//EI of embedment is the minimal value between EI of bar1 and EI of bar2
input link_flexion_elem 1 2

//hector for creating a new structure from an image file: open the image, open hector, ctrl+shift+d to increase the transparence of hector windows in order to see the image below
//to input the tranparence: install compiz, in compiz go in accessibilité, opacité, augmenter, saisir combinaison de touches, Ctrl+Shift+u, valider,
//reduire, saisircombinaison de touches, Ctrl+Shift+d, valider

//solver is gauss by default :  type_solver, if the solver is pardiso use (WARNING: not working!!)
input type_solver 2

//to ensure that cables remain in contact with the bottom (more exacly at a distance less that the radius of the cable
//in the following line 2 cables (4 and 7) hve to renain ins contact with the bottom otherwies this case is remove of the optimisation process
optimization_bottom_contact 2 4 7

//to display the Mesh number and the netting surface by panel and by orientation of the normal of the netting relatively to the flow. Indicate the nb of panels, the panels number, the angle step (deg).
//in the last line  
/the orientation for 14 panels by 5deg step are displayed first in number of meshes and second in netting surface (m²)
output orientation_netting 14 1 2 3 4 5 6 7 8 9 10 11 12 13 14  5.0

//installation of PARDISO
// go on http://software.intel.com/en-us/articles/non-commercial-software-download/
// you must be root
// select Intel® Math Kernel Library (Intel® MKL) for Linux
// Indicates a required field in the form
// Select file: Product for 32-bit/x86-64bit development (387 MB)
// Select delivery mechanism: Browser (http)
// download now, wait few minutes
// mkdir rpm
// copy the file in rpm
// select the file and extract
// You have to know the architecture of you computer (32 or 64 bits), to know use command "arch"
// if the answer is "i686" it is a 32 bits, if the answer is "x86_64" it is a 64 bits
// sudo apt-get install alien
// cd rpm/l_mkl_10.3.7.256/rpms
// ls -l
// sudo alien intel-mkl-sp1-256-10.3-7.i486.rpm
// wait despite the error message and the file intel-mkl-sp1-256_10.3-8_i386.deb
// sudo alien intel-mkl-sp1-devel-256-10.3-7.i486.rpm
// wait despite the error message and the file intel-mkl-sp1-devel-256_10.3-8_i386.deb is ceated
// click on intel-mkl-sp1-256_10.3-8_i386.deb
// install the package
// click on intel-mkl-sp1-devel-256_10.3-8_i386.deb
// install the package http://software.intel.com/en-us/articles/intel-mkl-link-line-advisor/
// For the linker go on http://software.intel.com/en-us/articles/intel-mkl-link-line-advisor/
// Select Intel® product: intel(R) MKL 10.3
// Select OS: linux
// Select processor architecture: IA-32
// Select processor architecture: GNU C/C++
// Select dynamic or static linking: Static
// Select sequential or multi-threaded layer: Multo-threaded
// Select OpenMP library: GNU(libgomp)
// dont touch Select cluster library:
// a line is in the window "Use this link line: " such as
// -Wl,--start-group  $(MKLROOT)/lib/ia32/libmkl_intel.a $(MKLROOT)/lib/ia32/libmkl_gnu_thread.a $(MKLROOT)/lib/ia32/libmkl_core.a -Wl,--end-group -fopenmp -lpthread -lm
// open the makefile in unix and dyna2, add the previous line to cc $@.c libfil.a -L/usr/X11R6/lib/ -lm -o $@
// that gives
// cc $@.c libfil.a -L/usr/X11R6/lib/ -lm -o $@ -Wl,--start-group  $(MKLROOT)/lib/ia32/libmkl_intel.a $(MKLROOT)/lib/ia32/libmkl_gnu_thread.a $(MKLROOT)/lib/ia32/libmkl_core.a -Wl,--end-group -fopenmp -lpthread -lm
// to find MKLROOT, sudo updatedb and wait
// locate libmkl_solver.a (in fact here use a file.a you can see 2 lines before)
// you get something like /opt/intel/composer_xe_2011_sp1.7.256/mkl/lib/ia32/libmkl_solver.a
// that means 
// MKLROOT = /opt/intel/composer_xe_2011_sp1.7.256/mkl
// this line is the first of the makefile
// make


optimization_cable_length_maxi 4 1.76

//in case the  water speed is not constant on the depth
//the following means that at 60m deep the water speed is 0.0m/s à 10deg and at 59m deep the water speed is 1.5m/s à 20 deg
//not done in static not done in dynamic
input water_speed_depth 60 0.0 10.0 59 1.5 20.0


//the cable 1 has a flexion rigidity (EI) of 0.00012000N*m²
input EI_flexion_cable 1 0.00012000

//the two cable 1 and 6 has and angle of 160 deg.
//if they are aligned the angle is 180
//if they are perpendicular the angle is 90
//EI of embedment is the mean value of EI of cable 1 and EI of cable 2
input link_flexion_elem2 1 6 160

//to discretise a diamond panel in bar elements in place of triangular elements
//the following indicates that panel 5 is discretised in bar elements
//panneau[pa].type_maillage	= 3;		
Diamond_panel_2_bar_element 5

//to calculate the eigen period and eigen vectors, only in case of symmetric stiffbess matrix
//in the following the 8 first eigen modes are calculated
output eigenvalues 8

//to list the digging of the structure
//that give the y position of nodes whic dig and the digging. in *.sta file
output foot_print

//to list the drag of the structure in a grid
//the following gives the drag in a tab of step of 1.0m large along y and z axis. in *.sta file
output grid_drag 1.0

//to spread the drag on few triangles in case of doors
//give the number of triangles describing the door
//give the vertex number (3 times the number of triangles)
//give the number of type of nodes involved for the door
//give the types of nodes 
output grid_drag_door 2 27 28 26 26 25 27 4 4 4 5 5 

//to reduce the netting Cd in function of time
//in the following there are a table of 2 
//Cd=Cd*0.1 at 0s and Cd=Cd*0.2 at 2320s
input ratio_drag_panel  2 	
0 	2320
0.1 	0.2	

// if affichage de la surface filtree 	:	1
//write surface in nrj file in dynamique

//changement_variable2(90.0);  //in order to change the x coordinates in the towing direction which is in this case at 90 deg.
//if in don file affichage de la surface filtree 	:	1
//the variation of filtered surface is in nrj file

//in case of dynamics in order to save in *.ten the tension of all bars
output bar_tension

//in order to create nodes along the diagonals of meshes et not along twines
//in the following panel 1 is meshed each 1000 meshes along U diagonal and each 5 meshes along V diagonal
//the best is to have ropes around the panel of netting with the same step of meshing along ropes
//as the panel and to begin the meshing by the ropes
//only available for panel with only 4 corners.
//the Meshing step (m) of panel 1 is in this case not used
input Meshing_UV 1 1000 5

//in order to create nodes along the twines of meshes et not along diagonals
//in the following panel 1 is meshed each 1000 sides along u twines and each 5 sides along v twines
//the best is to have ropes around the panel of netting with the same step of meshing along ropes
//as the panel and to begin the meshing by the ropes
//only available for panel with only 4 corners
//the Meshing step (m) of panel 1 is in this case not used
input Meshing_uv 1 1000 5




//in order to change the water speed and the netting drag cd with the angle of netting.
// in the following for a normal of the netting between 10 and 15 deg, the speed will be 0.46 m/s and the cd 1.03
input angle_speed_cd 10  15     0.46     1.03

//vizualisation with waves
//in order to see the profil of waves, use an angle of view (at the bottom of Batz)
//equal to 180-alpha for 0<=alpha<=180
//equal to 540-alpha for 180<=alpha<=360
//with alpha the angle of wave direction as defined in don file

//in order to merge two nodes use the following with their total numbering
//it is just for two nodes not more
input 2globals_to_1global 1514 173

//element color in *.des file
0 : invisible
1 : black
2 : blue
3 : red
4 : green
5 : yellow

//in order to have specific color for element in batz and phobos
In the following lines cables 8 & 9 are green and cables 10 & 11 are red
output color_element   8     4
output color_element   9     4
output color_element  10     3
output color_element  11     3

//in order to have specific color for surface (or panel) in batz and phobos
In the following lines panels 8 & 9 are green and panels 10 & 11 are red
output color_surface   8     4
output color_surface   9     4
output color_surface  10     3
output color_surface  11     3




//in order to haul or shoot a cable For example the following command reduce the length of cable 14
//the bar elements vary between 0.010m and 25.0054m long
//there are 12 time step in the following table
// the second line indicates the times, the third the speed of reduction (to shoot the speed is < 0), the fourth line indicate the extremity by which the cable is reduced
input hauling_cable4   14 0.010 25.0054 12
502.5    	621.05   	858.15   	1095.25   	1332.35   	1569.45  	1806.55  	2043.65 	2280.75  	2517.85  	2754.95  	3050 
0.3280915  	0.4192035  	0.6014275  	0.6476359 	0.7226532  	0.8624705  	1.0208409 	1.1929073 	1.4543323  	1.8277355  	1.8187668  	1.8142825
2 		2 		2 		2 		2 		2 		2 		2 		2 		2 		2		2

//in order to calculate the total height of the structure. The result is recorded in the file output in the directiry ../hexa/unix_2004/output
//this result is used by the executable ../hexa/Mos_auto/ex
output Delta_h

//In order to calculated the curvature of element. The curvature is stored in *.cuv file. The *.cuv file begins by:
NOMBRE_NOEUDS =   1694
   node          curvature nb_nodes
      1       90.256467682      1
      2       70.551871987      1
      3       69.566649420      1
      4       52.504245894      1
      5       50.822480256      1
      6       36.099751463      1
      7       33.902109131      1
      8       21.021440073      1
      9       18.381986374      1
     10        6.806087192      1
     11        3.701935084      1
     12        7.066864206      1
     13       10.743652317      1
     14       21.125834194      1
     15       25.558592159      1
     16       35.868781447      1
     17       41.305288780      1
     18       51.718317207      1
     19       58.446159830      1
     20       68.943704297      1
     21       77.238727664      1
     22       87.532926322      1
     23       50.976903741      4
     24       68.596034950      1
 That means that node 22 has a curvature of 87.532926322  m-1 which has been calculated on 1 connexion of couple of  bars.
 And that node 23 has a curvature of 50.976903741 m-1 which has been calculated on 4 connexions of couple of   bars.
 //the command is
Output Curvature
								
//In order to calculate the energy spent in bottom in dynamic. The calculation is done by squarre of Energy_bottom.step. In the following
// the energy is calculted by squarre of 2m
output Energy_bottom_step 2
							
//in order to impose a constant tension in cable the int "constant_tension" equals 1. The tension is in double "tension_constant"
//in this case there is a limit length l_limit which corresponds to tension_constant (tension_constant = stiffness * (l_limit-l0) / l0)
//in  the following the cable 14 has a constant tension of 1000.0N if its length is long enough
input constant_tension_cable 14 1000.0
						
//in order to have a catch speed used by dyna2
//of 0.01 m³/s use 
input catch_dynamic 0.01
				
//in order to record the energy per time step in the *.nrj file
output nrj			
				
//in order to record the bars length per time step in the *.haul file
output haul			
				
//in case of circular speed of a node
//in the following example node 14 turns on a circle normal to (0 0 1) around the center (-10 21 -9) at a speed of 1 m/s
input circular_speed_node 14 0 0 1 -10 21 -9 1	

//in case of calculation of the total length along X Y and Z of the structure
//the result is in *.tmp file
output Delta_h

//in case of calculation of the total height and width of the structure
//the width is calculated between 89 and 98
//the height between 4 and 84
//the result is in *.tmp file
output Delta_h_v 89 98 4 84
		
//in case the drag coefficient and lift coefficient depends on the angle between cable element and current
//in the example below : 1 = numero of the bar element, 5 = number of angle where is defined drag and lift coefficient
//the angles in deg., the drag coef, the lift coef
//not compatible with input elem_noeud
input tab_drag_filt 1 5
0.0	45.0	90.0	135.0	180.0
0.1	1.0	1.5	1.0	0.1
0.0	1.0	0.0	1.0	0.0
//WARNING: NOT USABLE

//scalar product of VV and normal = us
us = produit_scal(VV, normal);


//cross product of S13 and S12 = NO
produit_vect3(S13, S12, NO);

//errors total drag is only along X axis -> try scalar product of drag by water speed

in case of error in batz animation/video:
convert-im6.q16: not authorized
sudo gedit /etc/ImageMagick-6/policy.xml
replace <policy domain="coder" rights="none" pattern="
by  	<policy domain="coder" rights="read|write" pattern="

//for ballasts
double 	lcube;		//size of the cube which represents the volume of floatability of the surface. It is centred on each extremity. 3*lcube³ = volume of surface
double 	pondFS[4];	//ponderation (>= 0.0 and <= 1.0) of drag force and floatability. pondFS = 0.0 if z-lcube/2 > mh. pondFS = 1.0 if z+lcube/2 < mh. otherwise pondFS = fabs(z-lcube/2)/lcube
idem for element

//lors de compilations: /usr/bin/ld: ne peut trouver -lXaw
/usr/bin/ld: ne peut trouver -lXmu
sudo apt-get update
sudo apt-get install libxaw7-dev



//In case of introducing a volume of water in cables (ballast)
//in the following line the ballast is for 3 cables (10 11 and 12).
//the maximal volumes per the 3 cables are 0.032 0.032 0.032 (m³)
//and the volume of the ballast is 0.19m^3
//if the ballast volume is larger the sum of maximal volumes per the cables, the ballast volume = the maximal volumes per the cables
//in the following the volume of ballast is 0.0942 which is 0.032 + 0.032 + 0.032
input ballast2 3 	10 11 12 	0.032 0.032 0.032	0.19


//In case of introducing a volume of water in cables in dynamic when input ballast2 has been used
//the following defines that the ballast 1 has a variation of volume of water between 2 times (0s and 100s) 
//the variation of volume is between 0.0m³ and 100m³
//this volume is >=0 and <= the sum of maximal volume of the cables in the ballast
//input ballast2 has to be used before input ballast_dynamic2
input ballast_dynamic2 1 4   0     10   20   30
                           0.0  0.19   0.19  0


//in order to have in the sta file the altitude of the first ballast. Has to be completed for several ballasts
//in .bal in dynamics
output ballast_altitude

//in order to calculate the position of the global center of gravity and the global center of floatability
output gravity_floatability					

//in order to calculate and record the volume inside netting behing a front plane normal to x axis
output netting_volume frontx

//WARNING : if a node is fix along one axe, for example Z axis and there is a limit (floor) along Z axis, for example -32m, and the node is above
the limit, the node lost is fixation 

output screen_classic for static and dynamic calculation
nbiter         Max (N)       Max (m)      Mean (N) Mean (m)  kadd (N/m)  kmin (N/m) kmean (N/m)  kmax (N/m)     end

output screen_nrj for dynamic calculation
Haul(W)     0 Bottom(W)     0 Element(W)     0 Surface(W)     0 Node(W)     0 nb_iter     1 times/End   0.354/1000.000


pb of #include <stdlib.h>
sudo apt-get install build-essential

pb #include <X11/Intrinsic.h>
sudo apt-get install libxt-dev

//calculation of wave length (lambda, m) taking into account depth (d, m) and period (T, s)
//equation1 : wave number : k = 2 pi /lambda
//equation2 : wave speed : c² = G/k tnah(k d)
//equation3 : wave length : lambda = c . T
//3 equations with 3 unknows (lambda, c and k) give one equation : G T² / 2 / pi tanh(2 pi /lambda) - lambda = 0
//this equation is solved in initialisation.c in unix


//3 wave models are usable: Airy intermediate depth, Stokes intermediate depth, Stokes 3d deep waters
//in case of Stokes 3d deep waters, the height crest to trough is not equal to wave height
//A calculation of wave height which gives the the height crest to trough equal to the wave height
//given in don file is calculated: find the lines such as
//crest to trough will be  0.236687 m
//For a crest to trough of 0.220000 m, 
//use a wave height of     0.206250 m
//In the previous lines it is said that if you have 0.22m in don file as wahe height
//it gives a height crest to trough of 0.236687 m. 
//For having  height crest to trough of 0.22m use a wave height of 0.206250 m
//For choosing the wave model:
input wave_model 1
//for using use Airy intermediate depth.
input wave_model 2
//for using use Stokes 2d intermediate depth.
input wave_model 3
//for using use Stokes 3d deep waters.

//in order  to store the stiffness matrix in *.sti file use:
output stiffness_matrix
//to display the matrix use ~/Documents/Stiffness_matrix stiff.m

In order the mesh by the following order : elements, diamond, hexagonal, coulisses, winches, use
Meshing order: all 

//In order to record the energy per time step in dynamic calculation use:
output nrj

//in order to add a numeric node in a diamond panel 2 at meshes coordinates 14.0 and 15.0 with the type of node 3
//use the following line
input add_node_panel 2 14.0 15.0 3

//contact between cables use: the following in order to take into account the contact between cables 197 and 183
//and the contact between cables 198 and 172
input cable_contact	197	183
input cable_contact	198	172


//in case openfoam is used with femnet, use
input openfoam /home/daniel/hexa/data_2001/rostock_99/C/
//1) if *.pre and *.spe dont exit (*.pre is a pressure file per triangular elemnt when *.spe file is a speed file per node)
//femnet calculates the equilibrium of the structure and save the result in *.sta as usual
//2) openfoam calculated the flow around the structure and create a *.pre or *.spe file
//3) if *.pre file exists femnet will use it or if *.spe file exists and *.pre dont exist femnet will use *.spe file for the calculation of equilibrium
//the path "/home/daniel/hexa/data_2001/rostock_99/C/" is used by openfoam


//in cas of use of
output pressure_file
//femnet wil create a file after the calculation of equilibrium a *.pre file with the pressure on each triangular element 
//calculated from morrison drag and lift

//in order to use paraview
output paraview

//in order to assess min max mean std_dev of exit size per diamond panel.
//exit size is the diameter of the maximal circle passing trough meshes per diamond panel
output exit_size_diamond_panel

//in order to have a deck. A deck is linked to a node (cf batz node_information number). This node is master_node. The deck is triangular. 
//The first  vertex remains at x1 m of master node along X
//The first  vertex remains at y1 m of master node along Y
//The first  vertex remains at z1 m of master node along Z
//The second vertex remains at x2 m of master node along X
//The second vertex remains at y2 m of master node along Y
//The second vertex remains at z2 m of master node along Z
//The third  vertex remains at x3 m of master node along X
//The third  vertex remains at y3 m of master node along Y
//The third  vertex remains at z3 m of master node along Z
// the deck has a thickness of thickness (m) and a stiffness of stiffness (N/m)
// in the following the masternode is, x1 is -5.0m ... z3 is -4.0m. The thikness is 2m and the stiffness is  100000N/m
input deck 1 	-5 -5 -4 	5 -5 -4		5 5 -4		2	100000

output mean_XYZ_desequilibrium
//display mean of X desequilibrium, mean of Y desequilibrium, mean of Z desequilibrium, 

//In case of foil (trawl door for example). In the following line the foil is modeled by node type 4. The actual surface of the foil is 4.5m².
//the surface of the model foil is 0.238m². The mass of the model foil in air is 12.7Kg. The mass of the model foil in water is 11.2Kg.
//the cd (along X axis) is 0.75. The cl (along Y) is 1.22. The cz (along Z) is 0.0.
//the orientation is such that Fd^Fl//Fz. For having Fl in opposite direction replace cl by -cl.
input foil 4 4.5 0.238 12.7 11.2 0.75 1.22 0.0

output foil2 4 4.5 0.75 1.22 0.0: In case of foil (trawl door for example). In this command the foil is
modelled by node type 4. The actual surface of the foil is 4.5m². The cd is 0.75. The cl is 1.22.
The cz (along Z) is 0.0.

//in order to model netting using numerical twines in place of triangular elements in a netting panel.
//The panel must be surrounded by ropes, even ropes are tiny. Use the following command, with 4 the netting panel, 
//10 the period of twines (numerical twines are 10 times larger than actual twines), 0.0 the position of the numerical U twines relatively to the period,
//0.5 the position of the numerical V twines relatively to the period, 3 the accuracy (nodes closer than 3 are merged), 
//2 the number of bar elements inside a full numerical twine:
input netting2ropes 4 10 0.0 0.5 3 2 

